//Create you project here from scratch
const moviesList = [
    { movieName: "Flash", price: 7 },
    { movieName: "Spiderman", price: 5 },
    { movieName: "Batman", price: 4 },
];

// Use moviesList array for displaing the Name in the dropdown menu
const dropDown = document.querySelector("#selectMovie");
let p = 7;
for (let i = 0; i < moviesList.length; i++) {
    const movie = moviesList[i];
    const opt = document.createElement("option");
    opt.textContent = movie.movieName + ` $` + movie.price;
    // store raw values so parsing isn't weird
    opt.dataset.name = movie.movieName;
    opt.dataset.price = movie.price;
    dropDown.add(opt);
}

// one listener (not per option)
dropDown.addEventListener("change", (event) => {
    const sel = event.target.selectedOptions[0]; // the chosen <option>
    const movName = document.querySelector("#movieName");
    const movPrice = document.querySelector("#moviePrice");
    const totalPEl = document.querySelector("#totalPrice");

    // update movie name/price
    movName.textContent = sel.dataset.name || "Flash";
    movPrice.textContent = "$" + (sel.dataset.price || 7);

    // keep current seat total consistent with new price
    p = Number(sel.dataset.price || 7);
    totalPEl.textContent = '$' + (p * arraySeats.length);

    // persist movie selection
    try {
        localStorage.setItem('selectedMovieIndex', String(dropDown.selectedIndex));
    } catch (_) { }
    recalcDynamicPricing();
});

//default case
{
    const movName = document.querySelector("#movieName");
    movName.textContent = "Flash";
    const movPrice = document.querySelector("#moviePrice");
    movPrice.textContent = "$7";
    const totalP = document.querySelector("#totalPrice");
    totalP.textContent = "$0";
}

// for the seats:
// First, assign seat labels like A1, A2... per row
const rows = document.querySelectorAll('#seatCont .row');
rows.forEach((row, rIndex) => {
    const letter = String.fromCharCode('A'.charCodeAt(0) + rIndex);
    const seatsInRow = row.querySelectorAll('.seat');
    // Tag row with zone class (front: A-B, standard: C-F, premium: G+)
    const zone = (rIndex <= 1) ? 'front' : (rIndex <= 4) ? 'standard' : 'premium';
    row.classList.add(`zone-${zone}`);
    seatsInRow.forEach((s, i) => {
        const label = `${letter}${i + 1}`;
        s.dataset.label = label;
        s.setAttribute('aria-label', `${label} seat`);
        s.setAttribute('role', 'button');
    });
});

//Add eventLister to each unoccupied seat
const seat = document.querySelectorAll("#seatCont .seat");
// const occupied = document.querySelectorAll(".seat.occupied"); // not used

const holder = document.querySelector("#selectedSeatsHolder");
const numSeats = document.querySelector("#numberOfSeat");

const countSeat = 0;
let arraySeats = []; // array of selected seat labels
const totalP = document.querySelector("#totalPrice");
const showtimeInput = document.querySelector("#showtime");
const hasPricing = !!(window.pricing && typeof window.pricing.computePrice === 'function');

// ---- Summary sync (reads existing DOM; no renames required)
function fmtCurrency(n){
    const x = Number(n ?? 0);
    return (isNaN(x) ? '$0.00' : new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(x));
}
function getSeatCount(){
    // Prefer live DOM; fallback to arraySeats if present
    const live = document.querySelectorAll('#seatCont .seat.selected').length;
    if (live) return live;
    try { if (Array.isArray(arraySeats)) return arraySeats.length; } catch(_) {}
    return 0;
}
function syncSummaryUI(){
    const sumTickets = document.getElementById('sumTickets');
    const sumPerSeat = document.getElementById('sumPerSeat');
    const sumTotal = document.getElementById('sumTotal');
    const breakdown = document.getElementById('priceBreakdown');
    if (!sumTickets || !sumPerSeat || !sumTotal) return; // summary not present

    const count = getSeatCount();
    // Read per-seat from #moviePrice; fallback to p variable or derive from total
    const mpEl = document.querySelector('#moviePrice');
    let per = 0;
    if (mpEl && mpEl.textContent){
        per = parseFloat(mpEl.textContent.replace(/[^0-9.]/g,''));
    } else if (typeof p === 'number') {
        per = p;
    }
    // Total from #totalPrice; fallback compute
    const tEl = document.querySelector('#totalPrice');
    let tot = 0;
    if (tEl && tEl.textContent){
        tot = parseFloat(tEl.textContent.replace(/[^0-9.]/g,''));
    } else {
        tot = +(per * count).toFixed(2);
    }
    // Movie label
    const sel = document.querySelector('#selectMovie');
    const mov = sel?.selectedOptions?.[0]?.dataset?.name || document.querySelector('#movieName')?.textContent || '';

    sumTickets.textContent = String(count);
    sumPerSeat.textContent = fmtCurrency(per || 0);
    sumTotal.textContent = fmtCurrency(tot || 0);
    if (breakdown){
        breakdown.textContent = count
            ? `${count} × ${fmtCurrency(per || 0)}${mov ? ` (${mov})` : ''}`
            : 'Select seats to see total';
    }
    // Label pluralization
    const lbl = document.getElementById('sumLabelTickets');
    if (lbl) lbl.textContent = count === 1 ? 'Ticket' : 'Tickets';
}

// Initial sync after DOM is ready
document.addEventListener('DOMContentLoaded', syncSummaryUI);

// Re-sync on common interactions (no-op if elements missing)
const seatCont = document.querySelector('#seatCont');
if (seatCont) seatCont.addEventListener('click', () => setTimeout(syncSummaryUI, 0));
const dd = document.querySelector('#selectMovie');
if (dd) dd.addEventListener('change', () => setTimeout(syncSummaryUI, 0));
const showtime = document.querySelector('#showtime');
if (showtime) showtime.addEventListener('change', syncSummaryUI);

// Also observe #totalPrice for any text mutations (covers your existing flows)
(function observeTotals(){
    const target = document.querySelector('#totalPrice');
    if (!target || !('MutationObserver' in window)) return;
    const mo = new MutationObserver(() => syncSummaryUI());
    mo.observe(target, { childList:true, characterData:true, subtree:true });
})();

// Helper: refresh focusability and aria-disabled based on occupancy
function refreshSeatA11y() {
    seat.forEach(s => {
        if (s.classList.contains('occupied')) {
            s.setAttribute('aria-disabled', 'true');
            s.tabIndex = -1;
        } else {
            s.setAttribute('aria-disabled', 'false');
            s.tabIndex = 0;
        }
    });
}
// Make seats focusable immediately
refreshSeatA11y();

function recalcDynamicPricing() {
    const moviePriceEl = document.querySelector("#moviePrice");
    if (!dropDown || !moviePriceEl || !totalP) return;

    const movNameEl = document.querySelector("#movieName");
    const sel = dropDown.selectedOptions[0];
    const movieName = sel?.dataset?.name || movNameEl?.textContent?.trim() || "Flash";
    const baseFromDataset = Number(sel?.dataset?.price);
    const fallbackBase = Number.isFinite(baseFromDataset) ? baseFromDataset : (Number.isFinite(p) ? p : 7);

    const seatNodes = document.querySelectorAll('#seatCont .seat');
    const occupiedCount = document.querySelectorAll('#seatCont .seat.occupied').length;
    const totalSeats = seatNodes.length || 1;
    const count = arraySeats.length;

    let when = new Date();
    if (showtimeInput?.value) {
        const parsed = new Date(showtimeInput.value);
        if (!Number.isNaN(parsed.getTime())) {
            when = parsed;
        }
    }

    let perSeat = fallbackBase;
    let total = fallbackBase * count;

    const pricingApi =
        (hasPricing && window.pricing) ||
        (window.pricing && typeof window.pricing.computePrice === 'function' ? window.pricing : null);

    if (pricingApi) {
        try {
            const result = pricingApi.computePrice({
                movie: movieName,
                seatLabels: arraySeats,
                occupiedCount,
                totalSeats,
                when
            });
            if (result && typeof result.perSeat === 'number' && Number.isFinite(result.perSeat)) {
                perSeat = result.perSeat;
            }
            if (result && typeof result.total === 'number' && Number.isFinite(result.total)) {
                total = result.total;
            } else {
                total = perSeat * count;
            }
        } catch (_) {
            perSeat = fallbackBase;
            total = fallbackBase * count;
        }
    }

    if (pricingApi?.rules?.cap) {
        const cap = pricingApi.rules.cap;
        if (typeof cap.min === 'number') perSeat = Math.max(cap.min, perSeat);
        if (typeof cap.max === 'number') perSeat = Math.min(cap.max, perSeat);
        total = perSeat * count;
    }

    const perSeatFixed = Number(perSeat || 0).toFixed(2);
    const totalFixed = Number(total || 0).toFixed(2);

    moviePriceEl.textContent = "$" + perSeatFixed;
    totalP.textContent = "$" + totalFixed;

    const breakdownEl = document.querySelector("#priceBreakdown");
    if (breakdownEl) {
        breakdownEl.textContent = `${count} × $${perSeatFixed} (${movieName})`;
    }

    p = Number(perSeatFixed);
}

if (showtimeInput) {
    showtimeInput.addEventListener('change', recalcDynamicPricing);
}
window.addEventListener('load', recalcDynamicPricing);

// Restore persisted selections and movie
(function restoreState() {
    // Apply occupied seats from storage
    try {
        const occupied = JSON.parse(localStorage.getItem('occupiedSeats') || '[]');
        if (Array.isArray(occupied) && occupied.length) {
            seat.forEach(s => {
                if (occupied.includes(s.dataset.label)) {
                    s.classList.add('occupied');
                }
            });
        }
    } catch (_) { }
    try {
        const savedMovieIndex = localStorage.getItem('selectedMovieIndex');
        if (savedMovieIndex !== null && dropDown.options[Number(savedMovieIndex)]) {
            dropDown.selectedIndex = Number(savedMovieIndex);
        }
    } catch (_) { }

    // Set movie name/price and p based on current dropdown selection
    const sel = dropDown.selectedOptions[0];
    const movName = document.querySelector("#movieName");
    const movPrice = document.querySelector("#moviePrice");
    p = Number(sel?.dataset?.price || 7);
    movName.textContent = sel?.dataset?.name || "Flash";
    movPrice.textContent = "$" + p;

    // Restore selected seats
    try {
        const stored = JSON.parse(localStorage.getItem('selectedSeats') || '[]');
        if (Array.isArray(stored) && stored.length) {
            const fragment = document.createDocumentFragment();
            seat.forEach(s => {
                const lbl = s.dataset.label;
                if (lbl && stored.includes(lbl) && !s.classList.contains('occupied')) {
                    s.classList.add('selected');
                    const el = document.createElement('div');
                    el.className = 'selectedSeat';
                    el.dataset.seatLabel = lbl;
                    el.textContent = lbl;
                    fragment.appendChild(el);
                }
            });
            if (fragment.childNodes.length) {
                holder.appendChild(fragment);
                const noSel = holder.querySelector('.noSelected');
                if (noSel) noSel.remove();
            }
            arraySeats = stored.filter(Boolean).filter(lbl => {
                // drop any that became occupied since last time
                const el = document.querySelector(`#seatCont .seat[data-label="${lbl}"]`);
                return el && !el.classList.contains('occupied');
            });
            numSeats.textContent = arraySeats.length;
            totalP.textContent = '$' + (p * arraySeats.length);
        }
    } catch (_) { }
    refreshSeatA11y();
    recalcDynamicPricing();
})();

// Proceed button enable/disable based on selection
const proceedBtn = document.querySelector("#proceedBtn");
function updateProceedState() {
    if (proceedBtn) {
        const count = arraySeats.length;
        proceedBtn.disabled = count === 0;
        const base = 'Continue';
        proceedBtn.textContent = count ? `${base} (${count})` : base;
    }
}
// set initial state (after possible restore)
updateProceedState();

// Theme toggle: persist and override system preference
(function initThemeToggle() {
    const toggle = document.querySelector('#themeToggle');

    function applyTheme(theme) {
        if (theme === 'dark') {
            document.body.setAttribute('data-theme', 'dark');
            if (toggle) toggle.checked = true;
        } else {
            // treat anything else as light
            document.body.setAttribute('data-theme', 'light');
            if (toggle) toggle.checked = false;
        }
    }

    // Apply saved choice or default to light
    try {
        const saved = localStorage.getItem('theme');
        if (saved === 'dark' || saved === 'light') {
            applyTheme(saved);
        } else {
            applyTheme('light');
        }
    } catch (_) { applyTheme('light'); }

    if (toggle) {
        toggle.addEventListener('change', (e) => {
            const theme = e.target.checked ? 'dark' : 'light';
            applyTheme(theme);
            try { localStorage.setItem('theme', theme); } catch (_) { }
        });
    }
})();

for (let i = 0; i < seat.length; i++) {
    seat[i].addEventListener("click", (event) => {
        if (!(event.target.classList.contains("selected"))) {
            if (!(event.target.classList.contains("occupied"))) {
                const label = event.target.dataset.label || "SEAT";
                const seatToAdd = document.createElement("div");
                seatToAdd.textContent = label;
                seatToAdd.className = "selectedSeat";
                seatToAdd.dataset.seatLabel = label;

                event.target.classList.add("selected");
                arraySeats.push(label);
                numSeats.textContent = arraySeats.length;
                totalP.textContent = '$' + (p * arraySeats.length);

                holder.append(seatToAdd);
                const noSel = holder.querySelector('.noSelected');
                if (noSel) noSel.remove();

                // persist selection
                try { localStorage.setItem('selectedSeats', JSON.stringify(arraySeats)); } catch (_) { }
                updateProceedState();
                recalcDynamicPricing();
            }
        } else {
            event.target.classList.remove('selected');
            const lbl = event.target.dataset.label;
            arraySeats = arraySeats.filter(l => l !== lbl);
            numSeats.textContent = arraySeats.length;

            const label = event.target.dataset.label;
            if (label) {
                const toRemove = holder.querySelector(`.selectedSeat[data-seat-label="${label}"]`);
                if (toRemove) toRemove.remove();
            }
            if (arraySeats.length == 0) {
                const msg = document.createElement('span');
                msg.className = 'noSelected';
                msg.textContent = 'No Seat Selected';
                holder.append(msg);
            }
            totalP.textContent = '$' + (p * arraySeats.length);

            // persist selection
            try { localStorage.setItem('selectedSeats', JSON.stringify(arraySeats)); } catch (_) { }
            updateProceedState();
            recalcDynamicPricing();
        }
    });

    // Keyboard support: Enter/Space toggles seat like click
    seat[i].addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar' || e.code === 'Space') {
            e.preventDefault();
            seat[i].click();
        }
    });
}

// Set current date in the UI
(function setCurrentDate() {
    const dateEl = document.querySelector('.date');
    if (!dateEl) return;
    const d = new Date();
    const months = [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
    ];
    const day = String(d.getDate());
    const month = months[d.getMonth()];
    const year = d.getFullYear();
    dateEl.textContent = `${day} ${month}, ${year}`;
})();

//Add eventLsiter to continue Button
const contBtn = document.querySelector("#proceedBtn");
contBtn.addEventListener("click", (event) => {
    const numOfSeats = document.querySelector("#numberOfSeat").innerHTML;
    if (numOfSeats == '0') {
        alert("Oops no seat Selected");
        return;
    }

    // snapshot booking details before mutating UI
    const bookedSeats = [...arraySeats];
    const sel = dropDown.selectedOptions[0];
    const bookedMovie = sel?.dataset?.name || 'Flash';
    const bookedPrice = p * bookedSeats.length;

    // mark all selected seats in the seat area as occupied (ignore legend icons)
    const selSeatsAll = document.querySelectorAll("#seatCont .seat.selected");
    selSeatsAll.forEach(s => {
        s.classList.add("occupied");
        s.classList.remove("selected");
    });
    refreshSeatA11y();

    // reset totals and UI
    arraySeats.length = 0;
    numSeats.textContent = 0;
    const price = document.querySelector("#totalPrice");
    price.textContent = "$0";
    holder.innerHTML = '<span class="noSelected">No Seat Selected</span>'

    // clear persisted selection since it's now booked
    try { localStorage.setItem('selectedSeats', '[]'); } catch (_) { }
    // persist occupied seats
    try {
        const prev = JSON.parse(localStorage.getItem('occupiedSeats') || '[]');
        const next = Array.from(new Set([...(Array.isArray(prev) ? prev : []), ...bookedSeats]));
        localStorage.setItem('occupiedSeats', JSON.stringify(next));
    } catch (_) { }
    updateProceedState();
    recalcDynamicPricing();

    // Build and show success modal (uses existing CSS)
    const overlay = document.createElement('div');
    overlay.className = 'overlay';

    const modal = document.createElement('div');
    modal.className = 'successModal';

    const top = document.createElement('div');
    top.className = 'modalTop';
    // simple check mark SVG
    top.innerHTML = '<svg width="100" height="100" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="12" fill="lightgreen"/><path d="M7 12.5l3 3 7-7" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/></svg>';

    const center = document.createElement('div');
    center.className = 'modalCenter';
    const h1 = document.createElement('h1');
    h1.textContent = 'Booking Confirmed';
    const pEl = document.createElement('p');
    const seatsText = bookedSeats.length ? bookedSeats.join(', ') : '—';
    pEl.textContent = `Movie: ${bookedMovie} • Seats: ${seatsText} • Total: $${bookedPrice}`;
    center.append(h1, pEl);

    const bottom = document.createElement('div');
    bottom.className = 'modalBottom';
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.textContent = 'Done';
    bottom.append(closeBtn);

    modal.append(top, center, bottom);

    // attach and activate
    document.body.append(overlay, modal);
    document.body.classList.add('modal-active');

    function closeModal() {
        modal.remove();
        overlay.remove();
        document.body.classList.remove('modal-active');
    }

    overlay.addEventListener('click', closeModal);
    closeBtn.addEventListener('click', closeModal);

    // Close on Escape
    function onEsc(ev) { if (ev.key === 'Escape') { closeModal(); document.removeEventListener('keydown', onEsc); } }
    document.addEventListener('keydown', onEsc);
});

//Add eventListerner to Cancel Button
const cancelBtn = document.querySelector("#cancelBtn");
cancelBtn.addEventListener("click", (event) => {
    // Only clear selected seats inside the seat container; keep legend icons intact
    const selSeatsAll = document.querySelectorAll("#seatCont .seat.selected");
    selSeatsAll.forEach(s => s.classList.remove("selected"));

    arraySeats.length = 0;
    numSeats.textContent = 0;

    const price = document.querySelector("#totalPrice");
    price.textContent = "$0";

    holder.innerHTML = '<span class="noSelected">No Seat Selected</span>';
    // (leaving movie selection as-is on cancel, your default block already set initial)

    // clear persisted selection on cancel
    try { localStorage.setItem('selectedSeats', '[]'); } catch (_) { }
    updateProceedState();
    refreshSeatA11y();
    recalcDynamicPricing();
});

// Click on a selected seat chip to deselect that seat
holder.addEventListener('click', (e) => {
    const chip = e.target.closest('.selectedSeat');
    if (!chip) return;
    const label = chip.dataset.seatLabel;
    const seatEl = document.querySelector(`#seatCont .seat[data-label="${label}"]`);
    if (seatEl && seatEl.classList.contains('selected')) {
        seatEl.click();
    }
});

// Delegated seat click fallback (idempotent)
(function ensureSeatClicksWork(){
  const cont = document.querySelector('#seatCont');
  if (!cont) return;
  cont.addEventListener('click', (e) => {
    const el = e.target.closest('.seat');
    if (!el || el.classList.contains('occupied')) return;
    el.classList.toggle('selected');
    // rebuild selection from DOM (avoids dupes)
    const labels = [...document.querySelectorAll('#seatCont .seat.selected')]
      .map(s => s.dataset.label).filter(Boolean);
    try { window.arraySeats = labels; } catch(_) {}
    // minimal total fallback if your dynamic engine isn’t present
    try {
      if (typeof recalcDynamicPricing === 'function') recalcDynamicPricing();
      else {
        const price = parseFloat((document.querySelector('#moviePrice')?.textContent||'0').replace(/[^0-9.]/g,'')) || (typeof p==='number'?p:0);
        const tEl = document.querySelector('#totalPrice');
        if (tEl) tEl.textContent = '$' + (price * labels.length).toFixed(2);
      }
    } catch(_) {}
    try { if (typeof syncSummaryUI === 'function') syncSummaryUI(); } catch(_) {}
  }, { capture:false });
})();

// Prefill showtime if empty: next 19:00
(function defaultShowtime(){
  const el = document.getElementById('showtime');
  if (!el || el.value) return;
  const now = new Date();
  const when = new Date(now);
  when.setHours(19,0,0,0);
  if (when <= now) when.setDate(when.getDate()+1);
  const pad = n => String(n).padStart(2,'0');
  el.value = `${when.getFullYear()}-${pad(when.getMonth()+1)}-${pad(when.getDate())}T${pad(when.getHours())}:${pad(when.getMinutes())}`;
})();

// Mirror human-friendly date under existing date label if present
(function mirrorDate(){
  const el = document.getElementById('showtime');
  const dateBlock = document.querySelector('#dateHuman'); // create lazily
  if (!el) return;
  function render(){
    const v = el.value ? new Date(el.value) : new Date();
    const pretty = v.toLocaleString(undefined, { weekday:'short', day:'2-digit', month:'short', hour:'2-digit', minute:'2-digit' });
    let holder = document.querySelector('#dateHuman');
    if (!holder){
      holder = document.createElement('div'); holder.id = 'dateHuman';
      holder.style.opacity = .8; holder.style.marginTop = '6px'; holder.style.fontSize = '.95rem';
      const anchor = document.querySelector('#moviePrice') || document.querySelector('#movieName') || el;
      anchor.parentElement.insertBefore(holder, anchor.nextSibling);
    }
    holder.textContent = `Showtime: ${pretty}`;
  }
  el.addEventListener('change', render); render();
})();

// --- Enforce "use now" for pricing; keep idempotent
(function enforceNowShowtime(){
  if (window.__enforceNowShowtime) return;
  window.__enforceNowShowtime = true;

  // Always use current time
  window.currentShowtime = function(){ return new Date(); };

  // Make any existing #showtime input inert & hidden
  try {
    const el = document.getElementById('showtime');
    if (el) {
      el.value = '';
      el.setAttribute('hidden','');
      el.setAttribute('aria-hidden','true');
      el.disabled = true;
      el.style.display = 'none';
      // Remove previous listeners if any
      el.replaceWith(el.cloneNode(true));
    }
  } catch(_) {}

  // If a dynamic pricing engine exists, force when=now
  try {
    const p = window.pricing;
    if (p && typeof p.computePrice === 'function' && !p.__wrappedForNow) {
      const orig = p.computePrice;
      p.computePrice = function(args = {}) {
        // Always override with current time
        return orig({ ...(args||{}), when: new Date() });
      };
      p.__wrappedForNow = true;
    }
  } catch(_) {}

  // One-time refresh
  try { if (typeof recalcDynamicPricing === 'function') recalcDynamicPricing(); } catch(_) {}
  try { if (typeof syncSummaryUI === 'function') syncSummaryUI(); } catch(_) {}
})();

// --- Remove stray "Showtime" label (we use current time implicitly)
(function removeStrayShowtimeLabel(){
  function hideText(host){
    if (!host) return;
    const walker = document.createTreeWalker(host, NodeFilter.SHOW_TEXT);
    const re = /\bShowtime\b/i;
    let n;
    while ((n = walker.nextNode())) {
      const txt = (n.nodeValue || '').trim();
      if (re.test(txt)) {
        const span = document.createElement('span');
        span.hidden = true; span.style.display = 'none';
        n.parentNode.replaceChild(span, n);
      }
    }
  }
  const select = document.getElementById('selectMovie');
  const scope = (select && select.closest('.selectMovie')) || document.body;
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => hideText(scope));
  } else {
    hideText(scope);
  }
})();

// --- Clarify pricing is live/now when no seats are selected
(function clarifyLivePricing(){
  const holder = document.getElementById('priceBreakdown');
  if (!holder) return;
  const update = () => {
    const count = document.querySelectorAll('#seatCont .seat.selected').length;
    if (count === 0) holder.textContent = 'Live pricing (now)';
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', update);
  } else {
    update();
  }
  try {
    const tEl = document.querySelector('#totalPrice');
    if (tEl && 'MutationObserver' in window) {
      new MutationObserver(update).observe(tEl, { childList:true, characterData:true, subtree:true });
    }
  } catch (_) {}
})();
